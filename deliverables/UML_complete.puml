@startuml

'GAME AND BOARD:

class GameAsset {
    + {static} List<Card> getResourceCards()
    + {static} List<Card> getGoldenCards()
    + {static} List<Card> getStarterCards()
    + {static} List<Objective> getObjectives()
    - GameAssets()
}

'GameAsset -- Card
'GameAsset -- Objective

class Game {
    - String id   
    - GameStatus status
    - List<PlayerProfile> playerProfiles
    - Map<PlayerProfile, PlayerData> playersData
    - Map<PlayerProfile, PlayArea> playAreas
    - Set<Objective> commonObjectives
    - int currentPlayer
    - Board board

    + Game(Iterable<PlayerProfiles> playerProfiles)
    + getId() String
    + getPlayerProfiles() List<PlayerProfile>
    + getPlayerData(PlayerProfile pp) PlayerData
    + getPlayArea(PlayerProfile pp) PlayArea
    + getCurrentPlayer() PlayerProfile
    + getCommonObjectives() Set<Objective>
    + getStatus() GameStatus
    + startGame() void
    + pausedGame() void
    + resumeGame() void
    + join(PlayerProfile pp) PlayerData
    + selectStartingCardSide(PlayerProfile pp, Side s) void
    + selectColor(PlayerProfile pp, PlayerColor pc) SelectionResult
    + selectObjective(PlayerProfile pp, Objective o) void
    + drawCard(PlayerProfile pp, DrawSource ds) DrawResult
    + placeCard(PlayerProfile pp, Card c, Side s, int i, int j) void
}

class Board {
    - Set<FaceUpCard> faceUpResourceCards
    - Set<FaceUpCard> faceUpGoldenCards
    - Deck resourceCardDeck
    - Deck goldenCardDeck

    + Board()
    + getFaceUpResourceCards() Set<Card>
    + getFaceUpGoldenCards() Set<Card>
    + getResourceCardDeck() Deck
    + getGoldenCardDeck() Deck
}

'Board and PlayAreas exists only in a Game
Board <--* Game
PlayArea <--* Game
Objective <-- Game
PlayerData <-- Game 
PlayerProfile <-- Game

interface DrawSource {
    + Optional<Card> draw()
}

DrawSource <|.. FaceUpCard 
class FaceUpCard {
    - Optional<Card> card
    - Deck source

    + FaceUpCard()
    + draw() Optional<Card>
    + getCard() Optional<Card>
}

class Deck {
    - List<Card> cards

    + Deck(Iterable<Card> cards)
    + shuffle() void
    + isEmpty() boolean
    + draw() Optional<Card>
}

'Decks are aggregations of Cards, FaceUpCards have a reference to a Deck
Card --o Deck
Deck <-- FaceUpCard

'Decks exists only in a Board 
Deck <--* Board
FaceUpCard <--* Board

'PLAYERPROFILE, PLAYERDATA, CHOICE

class PlayerProfile {
    - String name

    + PlayerProfile(String name)
    + isConnected() boolean
}

class Choice<T> {
    - Set<T> options
    - OptionalInt selection

    + Choice(Iterable<T> choiches)
    + getOptions() Set<T>
    + select(T selection) void
    + hasSelected() boolean
    + getSelected() T    
}

class MultichooserChoiceArbiter<T,I> {
    - Set<T> options
    - Map<I, T> selections
    - boolean settled

    - List<MultichooserChoice<T>> choosers

    + MultichooserChoiceArbiter(Iterable<T> choiches, int choosers)
    + getChoice(I identity) MultichooserChoice<T>
}

class MultichooserChoice<T,I> {
    - MultichooserChoiceArbiter parent
    - I identity

    - MultichooserChoice(MultichooserChoiceArbiter parent, I identity)
    + getOptions() List<T>
    + select(T choice) SelectionResult
    + hasSelected() boolean
    + getSelected() T
    + getContenders(T choice) Set<I>
    + isSettled() boolean
}

enum SelectionResult {
    OK
    CONTENDED
}

class PlayerData {
    - List<Card> hand
    - Choice<Side> startingCardSideChoice
    - Choice<Objective> objectiveChoice
    - MultichooserChoice<PlayerColor, PlayerProfile> colorChoice

    + PlayerData(Card starterCard, Choice<Side> startingCardSideChoice, Choice<Objective> objectiveChoice, MultichooserChoice<PlayerColor, PlayerProfile> colorChoice)
    + getHand() List<Card>
    + getObjectiveChoice() Choice<Objective>
    + getColorChoice() MultichooserChoice<PlayerColor, PlayerProfile>
}

MultichooserChoice <-- PlayerData
Choice <-- PlayerData
MultichooserChoiceArbiter -- MultichooserChoice

'PLAYAREA, CARDPLACEMENT, CARD

interface Iterable<CardPlacement>
interface Comparable<CardPlacement>

class Position {
    - int i
    - int j

    + Position(int i, int j)
    + getI()
    + getJ()
}

Iterable <|-- PlayArea
class PlayArea {
    - Map<Position, CardPlacement> cards
    - int score
    - int seq
    - Map<Collectible, Integer> collectibleCount

    + PlayArea(Card starterCard, Side side)
    + placeAt(int i, int j, Card c, Side side) CardPlacement
    + getAt(int i, int j) Optional<CardPlacement>
    + getCollectibleCount() Map<Collectible, Integer>
    + getScore() int
    + iterator() Iterator<CardPlacement>
    + windows(int width, int height) WindowIterator
}

Comparable <|.. CardPlacement
class CardPlacement {
    - PlayArea playArea
    - int i
    - int j
    - Card card
    - Side side
    - int seq
    - int points
    
    - CardPlacement(PlayArea playArea, int i, int j, Card card, Side side, int seq);
    - calculatePoints() int
    + getPlayArea() PlayArea
    + getI() int
    + getJ() int
    + getCard() Card
    + getSide() Side
    + getVisibleFace() CardFace
    + getPoints() int
    + getCollectibleAtCorner(CornerPosition cp) Optional<Collectible>
    + getRelative(CornerPosition cp) Optional<CardPlacement>
    + getCovered() Map<CornerPosition, CardPlacement>
    + compareTo(CardPlacement other) int
}

CardPlacement <--* PlayArea
Card <-- CardPlacement 
PlayArea <-- Window
Position <-- PlayArea

class Card {
    - CardColor baseColor
    - boolean isStarter
    - boolean isGold
    - FrontCardFace front
    - BackCardFace back

    + color() CardColor
    + isStarter() boolean
    + isGold() boolean
    + getFace(Side s) CardFace
}

Card <-- PlayerData

interface CardFace {
    + corner(CornerPosition cornerPosition) Corner
    + getPointsPanel() Optional<PointsPanel>
    + getPlacementConstraint() Optional<PlacementConstraint>
    + getCenterResources() Map<Resource, Integer>
}

CardFace <|.. BaseCardFace
abstract class BaseCardFace {
    - Corner tl
    - Corner tr
    - Corner br
    - Corner bl

    + BaseCardFace(Corner tl, Corner tr, Corner br, Corner bl)
    + corner(CornerPosition cornerPosition) Corner
    + getPointsPanel() Optional<PointsPanel>
    + getPlacementConstraint() Optional<PlacementConstraint>
    + getCenterResources() Map<Resource, Integer>
}

BaseCardFace <|-- FrontCardFace
class BackCardFace {
    - Map<Resource, Integer> resources

    + BackCardFace(Corner tl, Corner tr, Corner br, Corner bl, Iterable<Resource> resources)
    + getCenterResources() Map<Resource, Integer>
}

BaseCardFace <|-- BackCardFace
class FrontCardFace {
   - PlacementConstraint placementConstraint
    - Optional<PointsPanel> pointsPanel

    + FrontCardFace(Corner tl, Corner tr, Corner br, Corner bl, lacementConstraint placementConstraint,  Optional<PointsPanel> pointsPanel)
    + getPointsPanel() Optional<PointsPanel>
    + getPlacementConstraint() Optional<PlacementConstraint>
}

FrontCardFace <--* Card
BackCardFace <--* Card

class PlacementConstraint {
    - Map<Resource, Integer> requiredResources

    + PlacementConstraint(Map<Resource, Integer> requiredResources)
    + isSatisfied(PlayArea playArea) boolean
}

PlacementConstraint <--* FrontCardFace

class Corner {
    - socket boolean
    - Optional<Collectible> collectible

    - Corner(boolean isSocket, Optional<Collectible>)
    + {static} missing() Corner
    + {static} empty() Corner
    + {static} filled(Collectible collectible) Corner
    + isSocket() boolean
    + getCollectible() Optionl<Collectible>
}

Corner <--* BaseCardFace

class WindowIterator {
    - int offsetI
    - int offsetJ
    - int maxI
    - int maxJ
    - int w
    - int h

    + hasNext() boolean
    + next() Window
}

class Window {
    - PlayArea playArea
    - int offsetI
    - int offsetJ
    - int width
    - int height

    + width() int
    + height() int
    + getAt(int i, int j) Optional<CardPlacement>
}

WindowIterator -- Window

interface PointsPanel {
    + calculateScoredPoints(CardPlacement cp) int
}

PointsPanel <|.. SimplePointsPanel
class SimplePointsPanel {
    - int points
    + SimplePointsPanel(int points)
    + calculateScoredPoints(CardPlacement cp) int
}

PointsPanel <|.. CornerCoverPointsPanel
class CornerCoverPointsPanel {
    - int pointsPerCorner
    + CornerCoverPointsPanel(int pointsPerCorner)
    + calculateScoredPoints(CardPlacement cp) int
}

PointsPanel <|.. ItemPointsPanel
class ItemPointsPanel {
    - Item item
    - int pointsPerItem
    + ItemPointsPanel(Item item, int pointsPerItem)
    + calculateScoredPoints(CardPlacement cp) int
}

PointsPanel <.. FrontCardFace : use

abstract class Objective {
    - int points

    + Objective(int points)
    + getPointsPerMatch() int
    + test(PlayArea pa) Set<Set<CardPlacement>>
}

Objective <|-- CollectibleObjective
class CollectibleObjective {
    - Map<Collectible, Integer> requiredCollectibles
    + CollectibleObjective(int points, Map<Collectible, Integer> requiredCollectibles)
    + test(PlayArea pa) Set<Set<CardPlacement>>
}

Objective <|-- PatternObjective
class PatternObjective {
    - CardColor[][] pattern
    + PatternObjective(int points, CardColor[][] pattern)
    + test(PlayArea pa) Set<Set<CardPlacement>>
}

enum GameStatus {
    AWAITING_PLAYERS
    SETUP_STARTING_CARD_SIDE
    SETUP_COLOR
    SETUP_OBJECTIVE
    PLAY_PLACING
    PLAY_DRAWING
    FINISHED
    SUSPENDED
}

enum CardColor {
    üî¥ RED
    üü¢ GREEN
    üîµ BLUE
    üü£ PURPLE
    ‚ö™ NEUTRAL
}

enum Side {
    FRONT
    BACK
}

enum CornerPosition {
    TOP_RIGHT
    TOP_LEFT
    BOTTOM_LEFT
    BOTTOM_RIGHT
}

interface Collectible {

}

enum Resource {
    üçÉ PLANT
    üçÑ FUNGI
    ü¶ä ANIMAL
    ü¶ã INSECT

    + getAssociatedColor() CardColor
}

enum Item {
    ü™∂ QUILL
    ü´ô INKWELL
    üìú MANUSCRIPT
}

Collectible <|.. Resource
Collectible <|.. Item

enum PlayerColor {
    üî¥ RED
    üü¢ GREEN
    üîµ BLUE
    üü° YELLOW
}

'ENUM REF
PlayArea .. Collectible
PlayerColor .. PlayerData
CardColor .. Card
Side .. Card
Game .. GameStatus
CornerPosition .. BaseCardFace
MultichooserChoice .. SelectionResult
'PatternObjective .. CardColor

@enduml