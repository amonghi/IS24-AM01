@startuml
'this collapses nested packages if there are no in-between classes
!pragma useIntermediatePackages false


/'
CONVENTIONS FOR ARROW DECLARATION:
- if possible, use `implements` and `extends`
- declare arrow before class: if class extends other class or implements interface
    (declare arrow near the child class not the parent class)
- declare arrow after class: if class uses or is in some other way related to another class
    (do not declare arrow near the used class, declare it near the user)
'/

package java.lang {
    interface Iterable<T> {}
    interface Comparable<T> {}
}

package collectible {
    interface Collectible {}
    note top of Collectible : sealed interface

    enum Resource implements Collectible {
        <:seedling:> PLANT
        <:mushroom:> FUNGI
        <:fox_face:> ANIMAL
        <:butterfly:> INSECT

        + getAssociatedColor() CardColor
    }

    enum Item implements Collectible {
        <:feather:> QUILL
        <:jar:> INKWELL
        <:scroll:> MANUSCRIPT
    }
} /' end package collectible '/

package card {
    package face {
        package corner {
            class Corner {
                - socket boolean
                - Collectible collectible

                - Corner(Collectible collectible, boolean socket)
                - Corner(boolean socket)
                + {static} missing() Corner
                + {static} empty() Corner
                + {static} filled(Collectible collectible) Corner
                + isSocket() boolean
                + getCollectible() Optional<Collectible>
            }
            Collectible .. Corner
            note top of Corner : !isSocket() ==> getCollectible().isEmpty()

            enum CornerPosition {
                TOP_RIGHT
                TOP_LEFT
                BOTTOM_LEFT
                BOTTOM_RIGHT

                + getOppisite() CornerPosition
            }
        } /' end package corner '/

        package placement {
            class PlacementConstraint {
                - Map<Resource, Integer> requiredResources

                + PlacementConstraint(Map<Resource, Integer> requiredResources)
                + isSatisfied(PlayArea playArea) boolean
            }
        } /' end package placement '/

        package points {
            interface Points {
                + calculateScoredPoints(PlayArea.CardPlacement cp) int
            }

            class SimplePoints implements Points {
                - int points
                + SimplePoints(int points)
                + calculateScoredPoints(PlayArea.CardPlacement cp) int
            }

            class CornerCoverPoints implements Points {
                - int pointsPerCorner
                + CornerCoverPoints(int pointsPerCorner)
                + calculateScoredPoints(PlayArea.CardPlacement cp) int
            }

            class ItemPoints implements Points {
                - Item item
                - int pointsPerItem
                + ItemPoints(Item item, int pointsPerItem)
                + calculateScoredPoints(PlayArea.CardPlacement cp) int
            }
        } /' end package points '/

        interface CardFace {
            + corner(CornerPosition cp) Corner
            + getPoints() Optional<Points>
            + getPlacementConstraint() Optional<PlacementConstraint>
            + getCenterResources() Map<Resource, Integer>
        }

        abstract class BaseCardFace implements CardFace {
            - Corner tl
            - Corner tr
            - Corner br
            - Corner bl

            + BaseCardFace(Corner tl, Corner tr, Corner br, Corner bl)
            + corner(CornerPosition cp) Corner
            + getPoints() Optional<Points>
            + getPlacementConstraint() Optional<PlacementConstraint>
            + getCenterResources() Map<Resource, Integer>
        }
        Corner <--* BaseCardFace
        CornerPosition .. BaseCardFace
        note left of BaseCardFace::getPoints
            Default implementation. Returns Optional.empty().
        end note
        note left of BaseCardFace::getPlacementConstraint
            Default implementation. Returns Optional.empty().
        end note
        note left of BaseCardFace::getCenterResources
            Default implementation. Returns empty list.
        end note

        class BackCardFace extends BaseCardFace {
            - Map<Resource, Integer> resources

            + BackCardFace(Corner tl, Corner tr, Corner br, Corner bl, Map<Resource, Integer> resources)
            + getCenterResources() Map<Resource, Integer>
        }

        class FrontCardFace extends BaseCardFace {
            - PlacementConstraint placementConstraint
            - Points points

            + FrontCardFace(Corner tl, Corner tr, Corner br, Corner bl, placementConstraint placementConstraint,
                Points points)
            + FrontCardFace(Corner tl, Corner tr, Corner br, Corner bl, Points points)
            + FrontCardFace(Corner tl, Corner tr, Corner br, Corner bl)
            + getPoints() Optional<Points>
            + getPlacementConstraint() Optional<PlacementConstraint>
        }
        PlacementConstraint <--* FrontCardFace
        Points <--* FrontCardFace
    } /' end package face '/

    class Card {
        - int id
        - CardColor baseColor
        - boolean isStarter
        - boolean isGold
        - FrontCardFace front
        - BackCardFace back

        + Card(int id, CardColor baseColor, boolean isStarter, boolean isGold, FrontCardFace front, BackCardFace back)
        + id() int
        + color() CardColor
        + isStarter() boolean
        + isGold() boolean
        + getFace(Side s) CardFace
    }
    FrontCardFace <--* Card
    BackCardFace <--* Card
    Side .. Card
    CardColor .. Card

    enum CardColor {
        <:red_circle:> RED
        <:green_circle:> GREEN
        <:blue_circle:> BLUE
        <:purple_circle:> PURPLE
        <:white_circle:> NEUTRAL
    }
    note left of CardColor::NEUTRAL
        Starter cards have neutral color.
    end note

    enum Side {
        FRONT
        BACK
    }
} /' end package card '/

package objective {
    abstract class Objective {
        - int points

        + Objective(int points)
        + getPointsPerMatch() int
        + getEarnedPoints(PlayArea pa) int
    }

    class SameCollectibleObjective extends Objective {
        - Collectible requiredCollectible
        - int requiredNumber
        + SameCollectibleObjective(int points, Collectible requiredCollectible, int requiredNumber)
        + getEarnedPoints(PlayArea pa) int
    }
    Collectible ... SameCollectibleObjective

    class DifferentCollectibleObjective extends Objective {
        - Set<Item> requiredItems
        + DifferentCollectibleObjective(int points, Set<Item> requiredItems)
        + getEarnedPoints(PlayArea pa) int
    }
    Collectible ... DifferentCollectibleObjective

    class PatternObjective extends Objective {
        - Map<Position, CardColor> pattern
        - Set<Set<CardPlacement>> matches
        + PatternObjective(int points, Map<Position, CardColor>)
        + getEarnedPoints(PlayArea pa) int
    }
    CardColor ... PatternObjective
} /' end package objective '/

package choice {
    class Choice<T> {
        - Set<T> options
        - T selection

        + Choice(Set<T> choices)
        + getOptions() Set<T>
        + select(T selection) void
        + getSelected() Optional<T>
    }

    class MultiChoice<T, I> {
        - Set<T> options
        - Map<I, MultiChoiceChoice> choices
        - boolean settled

        + MultiChoice(Set<T> choices, Set<I> chooserIdentities)
        - getContendersPerOption() Map<T, Set<I>>
        - everyoneHasChosen() boolean
        + getChoices() Map<I, MultiChoiceChoice>
    }
    MultiChoiceChoice <-- MultiChoice : < has many

    class MultiChoiceChoice<T, I> {
        - T selection

        - MultiChoiceChoice(I identity)
        + getOptions() Set<T>
        + select(T choice) SelectionResult
        + getSelected() Optional<T>
        + getContenders(T choice) Set<I>
        + isSettled() boolean
    }
    SelectionResult .. MultiChoiceChoice
    note right of MultiChoiceChoice
        This is an inner class
        the actual name is MultiChoice<T, I>.Choice
    end note

    enum SelectionResult {
        OK
        CONTENDED
    }
} /' end package choice '/

package player {
    class PlayerProfile {
        - String name

        + PlayerProfile(String name)
        + getName() String
        + isConnected() boolean
    }

    class PlayerData {
        - List<Card> hand
        - Objective objective
        - PlayerColor color

        + PlayerData(Card starterCard, Objective objectiveChoice, PlayerColor colorChoice)
        + getHand() List<Card>
        + getObjectiveChoice() Objective
        + getColorChoice() PlayerColor
    }
    Card <-- PlayerData : < has many \n in hand
    PlayerColor .. PlayerData

    enum PlayerColor {
        <:red_circle:> RED
        <:green_circle:> GREEN
        <:blue_circle:> BLUE
        <:yellow_circle:> YELLOW
    }
} /' end package player '/

package chat {
    abstract class Message {
        - PlayerProfile sender
        - String content
        
        + getSender() PlayerProfile
        + getContent() String
        + {abstract} isRecipient(PlayerProfile pp) boolean
    }

    class BroadcastMessage extends Message {
        + BroadcastMessage(PlayerProfile sender, String content)
        + isRecipient(PlayerProfile pp) boolean
    }
    note left of BroadcastMessage::isRecipient
        Always returns true.
    end note

    class DirectMessage extends Message {
        - PlayerProfile recipient

        + DirectMessage(PlayerProfile sender, PlayerProfile recipient, String content)
        + isRecipient(PlayerProfile pp) boolean
    }

    class ChatManager {
        - List<Message> messages
        
        + ChatManager()
        + send(Message message) void
        + getMailbox(PlayerProfile pp) List<Message>
    }
    Message <--* ChatManager
}

package game {
    class GameManager {
        - List<Game> games

        + GameManager(Path dataDir)
        + getGame() List<Game>
        + createGame() Game
        - loadSavedGamesIds() List<String>
        - loadGame(String id) Game
        + saveGame(Game game) void
    }
    Game <--* GameManager
    note left of GameManager::loadSavedGamesIds()
        Returns list of saved game IDs by reading filenames in the data directory.
    end note

    class Game {
        - String id
        - GameStatus status
        - List<PlayerProfile> playerProfiles
        - ChatManager chatManager

        'initial choices
        - Map<PlayerProfile, Choice<Side>> startingCardSideChoices
        - Map<PlayerProfile, MultiChoiceChoice<PlayerColor, PlayerProfile>> colorChoices
        - Map<PlayerProfile, Choice<Objective>> objectiveChoices

        'game data
        - Map<PlayerProfile, PlayerData> playersData
        - Map<PlayerProfile, PlayArea> playAreas
        - Set<Objective> commonObjectives
        - int currentPlayer
        - Board board

        + Game(String id)
        
        + getId() String
        + getPlayerProfiles() List<PlayerProfile>
        + getPlayerData(PlayerProfile pp) PlayerData
        + getPlayArea(PlayerProfile pp) PlayArea
        + getCurrentPlayer() PlayerProfile
        + getCommonObjectives() Set<Objective>
        + getStatus() GameStatus
        + getChatManager() ChatManager

        + startGame() void
        + pausedGame() void
        + resumeGame() void
        
        + join(PlayerProfile pp) void
        + selectStartingCardSide(PlayerProfile pp, Side s) void
        + selectColor(PlayerProfile pp, PlayerColor pc) SelectionResult
        + selectObjective(PlayerProfile pp, Objective o) void
        + drawCard(PlayerProfile pp, DrawSource ds) DrawResult
        + placeCard(PlayerProfile pp, Card c, Side s, int i, int j) void
    }
    'Board and PlayAreas exists only in a Game
    PlayerProfile <-- Game
    Choice <-- Game
    MultiChoiceChoice <-- Game
    Objective <-- Game
    ChatManager <--* Game
    Board <--* Game
    PlayArea <--* Game
    PlayerData <--* Game
    GameStatus .. Game
    note right of Game::startingCardSideChoices
        This gruop of fields are used during the setup phases of the game:
        * SETUP_STARTING_CARD_SIDE
        * SETUP_COLOR
        * SETUP_OBJECTIVE
    end note
    note right of Game::playersData
        This gruop of fields are used during the play phases of the game:
        * PLAY_PLACING
        * PLAY_DRAWING
    end note
    note left of Game::playerProfiles
        The players are stored in the order in which they play.
        players.get(0) is the first one to play.
    end note
    note left of Game::currentPlayer
        The index of the player currently playing
    end note

    enum GameStatus {
        AWAITING_PLAYERS
        SETUP_STARTING_CARD_SIDE
        SETUP_COLOR
        SETUP_OBJECTIVE
        PLAY_PLACING
        PLAY_DRAWING
        FINISHED
        SUSPENDED
    }

    class Board {
        - Set<FaceUpCard> faceUpResourceCards
        - Set<FaceUpCard> faceUpGoldenCards
        - Deck resourceCardDeck
        - Deck goldenCardDeck

        + Board(Set<FaceUpCard> faceUpResourceCards, Set<FaceUpCard> faceUpGoldenCards, Deck resourceCardDeck, Deck goldenCardDeck)
        + getFaceUpResourceCards() Set<FaceUpCard>
        + getFaceUpGoldenCards() Set<FaceUpCard>
        + getResourceCardDeck() Deck
        + getGoldenCardDeck() Deck
    }
    Deck <--* Board
    FaceUpCard <--* Board

    interface DrawSource {
        + Optional<Card> draw()
    }

    class FaceUpCard implements DrawSource {
        - Card card
        - Deck mainSource
        - Deck auxiliarySource

        + FaceUpCard(Deck mainSource, Deck auxiliarySource)
        + draw() Optional<Card>
        + getCard() Optional<Card>
        - Card drawFromDecks()
    }
    Deck <-- FaceUpCard : draws from

    class Deck implements DrawSource {
        - List<Card> cards

        + Deck(Iterable<Card> cards)
        + shuffle() void
        + isEmpty() boolean
        + draw() Optional<Card>
    }
    'Decks are aggregations of Cards
    Card --o Deck

    class Position {
        + {static} Position ORIGIN
        + int i
        + int j

        + getRelative(CornerPosition cp) Position
    }
    note top of Position
        this is an inner record class
        the actual name is PlayArea.Position
    end note

    Iterable <|.. PlayArea : <<bind>> \n PlayArea.CardPlacement
    class PlayArea {
        - Map<Position, CardPlacement> cards
        - int score
        - int seq
        - Map<Collectible, Integer> collectibleCount

        + PlayArea(Card starterCard, Side side)
        + placeAt(Position pos, Card c, Side side) PlayArea.CardPlacement
        + placeAt(int i, int j, Card c, Side side) PlayArea.CardPlacement
        - placeAt(Position position, Card card, Side side, boolean isFirst) PlayArea.CardPlacement
        + getAt(Position pos) Optional<PlayArea.CardPlacement>
        + getAt(int i, int j) Optional<PlayArea.CardPlacement>
        + getCollectibleCount() Map<Collectible, Integer>
        + getScore() int
        + iterator() Iterator<CardPlacement>
    }
    CardPlacement <--* PlayArea : < has many
    Position -- PlayArea

    Comparable <|.. CardPlacement : <<bind>> \n PlayArea.CardPlacement
    class CardPlacement {
        - Position position
        - Card card
        - Side side
        - int seq
        - int points

        - CardPlacement(Position position, Card card, Side side, int seq);
        - calculatePoints() int
        + getPlayArea() PlayArea
        + getPosition() PlayArea.Position
        + getCard() Card
        + getSide() Side
        + getVisibleFace() CardFace
        + getPoints() int
        + getRelative(CornerPosition cp) Optional<CardPlacement>
        + getTopPlacementAtCorner(CornerPosition cp) CardPlacement
        + getVisibleCollectibleAtCorner(CornerPosition cp) Optional<Collectible>
        + getCovered() Map<CornerPosition, CardPlacement>
        + compareTo(CardPlacement other) int
    }
    Card <-- CardPlacement
    note top of CardPlacement
        this is an inner class
        the actual name is PlayArea.CardPlacement
    end note
} /' end package game '/

@enduml
